# 网络编程

# 网络编程

## 1.1、概述

信件：

![image-20201116085214806](https://img2020.cnblogs.com/blog/2157769/202011/2157769-20201116085215041-2080498023.png)、

打电话：---连接---接了---通话 TCP

发短信：---发送了就完事了---接收 UDP

 

**计算机网络**：

计算机网络是指将**地理位置不同**的具有独立功能的**多台计算机及其外部设备**，通过**通信线路**连接起来，在网络操作系统，网络管理软件及**网络通信协议**的管理和协调下，**实现资源共享和信息传递**的计算机系统。

 

**网络编程的目的：**

传播交流信息，数据交换，通信。

 

**想要达到这个效果需要什么：**

1、如何准确地定位网络上的一台主机：（端口），定位到这个计算机的某个资源。

2、找到了这个主机，如何传输数据呢？

javaweb：网页编程 B/S
网络编程：TCP/IP C/S

## 1.2 网络通信的要素

 **通信双方的地址**

* ip
* 端口号
* 192.168.16.124：5900

**规则：网络通信协议**
TCP/IP参考模型 ：实际赢得
OSI七层参考模型 ：理想化的

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210126113217270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1OTExMjc4,size_16,color_FFFFFF,t_70)

网络编程的重点在传输层

小结

1. 网络编程中的两个主要问题

   * 如何准确定位到网络上的一台或者多台主机

   * 找到主机之后如何进行通信

2. 网络编程中的要素

   * IP和端口号 
   * 网络通信协议

3. 万物皆对象

## 1.3 IP 

ip地址：inetAddress

- 唯一定位一台网络上计算机
- 127.0.0.1：本机loaclhost
- Ip地址的分类
  - Ipv4/Ipv6
    - IPv4 127.00.1,四个字节组成，0-255，42亿~；30亿都在北美，亚洲四亿，2011年就用尽；
    - IPV6：128位，8个无符号整数！
  - 公网（互联网）-私网（局域网）
    - ABCD类地址
    - 192.168.xx.xx专门给组织内部使用的
- 域名：记忆IP问题！
  - IP：

```java
import java.net.InetAddress;
import java.net.UnknownHostException;

public class TestInetAddress {
    public static void main(String[] args) {
        try {
            //查询本机的IP地址
            InetAddress ip1 = InetAddress.getByName("127.0.0.1");
            System.out.println(ip1);
            InetAddress ip2 = InetAddress.getByName("localhost");
            System.out.println(ip2);
            InetAddress ip3 = InetAddress.getLocalHost();
            System.out.println(ip3);

            //查询网站的IP地址
            InetAddress ip4 = InetAddress.getByName("www.baidu.com");
            System.out.println(ip4);

            //常用的方法
            System.out.println(ip4.getAddress());
            System.out.println(ip4.getCanonicalHostName());
            System.out.println(ip4.getHostAddress());//标准IP地址
            System.out.println(ip4.getHostName()); //域名
        } catch (UnknownHostException e) {
            e.printStackTrace();
        }
    }
}

```

## 1.4端口

端口表示计算机一个程序的进程

* 不同进程有不同端口号， 用来区分软件
*  0 ~ 65535
* TCP UDP : 65536 * 2 TCP: 80 DUP:80,不同协议下端口号可以一样， 同意协议下 端口号不能冲突
* 端口分类
  * 公用端口 0~1023
    * http:80
    * https 43
    * ftp: 21 
    * telent: 23   //远程监听
  * 程序注册端口：1024~49151，分配给用户或者程序的
    * Tpmcat 8080 
    * MySql 3306
    * Oracle 1521
  * 动态端口 （私有端口）：49152~65535

```sh
 1、netstat -ano #查看所有的端口
 2、netstat -ano|findstr "9640" # 查看指定的窗口 其中|是指先干后面的再在前面中找
 3、tasklist|findstr "8696" #查看指定端口的进程
 #打开任务管理器看进程号
 # ctrl + shift + esc
```

## 1.5、通信协议

https://www.cnblogs.com/fundebug/p/differences-of-tcp-and-udp.html   

协议：约定，就好比我们现在说的是普通话。

**网络通信协议**：速率，传输码率，代码结构，传输控制。。。。。。

**问题**：非常的复杂

大事化小：分层！

**TCP/IP协议簇**：**实际上是一层协议**

重要：

- TCP:传输控制协议
- UDP:用户数据报协议

出名的协议：

- TCP：
- IP：网络互联协议

ps:应用层：QQ、微信；传输层：通信；网络层：分包；数据链路层：具体的传输：如光纤，海底电缆。。。。。。；

 

TCP UDP对比：

TCP：打电话

- 连接，稳定

- `三次握手、四次挥手`

  ```
   最少需要三次，才能保证稳定连接！
   A；你愁啥？
   B：瞅你咋地？
   A：干一场！
   
   
   A：我要走了
   B：你真的要走了吗？
   B：你真的真的要走了吗？
   A：我真的要走了！  
  ```

   

- 客户端、服务端

- 传输完成，释放连接，效率低

UDP：发短信

- 不连接，不稳定
- 客户端、服务端：没有明确的界限
- 不管有没有准备好，都可以发给你。。。
- 导弹攻击
- DDOS：洪水攻击！（饱和攻击）



## 1.6、TCP

有关socket的知识分享：https://www.cnblogs.com/dolphinx/p/3460545.html

客户端

1. 连接服务器Socket

2. 发送消息

3. 客户端代码

   ```java
   package ip.Socket;
   
   import java.io.IOException;
   import java.io.OutputStream;
   import java.net.InetAddress;
   import java.net.Socket;
   import java.net.UnknownHostException;
   import java.nio.charset.StandardCharsets;
   
   public class TcpClientDemo {
       public static void main(String[] args) {
           Socket socket = null;
           OutputStream os = null;
           try {
               //1 获取服务器的地址与端口号
               InetAddress severIP = InetAddress.getByName("127.0.0.1");
               int port = 9999;
               //2.创建一个socket连接
               socket = new Socket(severIP, port);
               //3.发送消息IO流
               os = socket.getOutputStream();
               os.write("I Love U! 亲爱的".getBytes());
   
           } catch (Exception e) {
               e.printStackTrace();
           }finally {
               if (os != null) {
                   try {
                       os.close();
                   } catch (IOException e) {
                       e.printStackTrace();
                   }
               }
               if (socket != null) {
                   try {
                       socket.close();
                   } catch (IOException e) {
                       e.printStackTrace();
                   }
               }
           }
       }
   }
   
   ```

   

服务器

1. 建立服务端口SeverSocket

2. 等待用无连接 accept

3. 接收消息

4. 服务器端代码

   ```java
   package ip.Socket;
   
   import java.io.ByteArrayInputStream;
   import java.io.ByteArrayOutputStream;
   import java.io.IOException;
   import java.io.InputStream;
   import java.net.ServerSocket;
   import java.net.Socket;
   import java.sql.SQLOutput;
   
   public class TcpSeverDemo {
       public static void main(String[] args) {
           ServerSocket serverSocket = null;
           Socket socket = null;
           ByteArrayOutputStream baos = null;
           InputStream is = null;
           try {
               // 1 需要创建一个服务器端口
               serverSocket = new ServerSocket(9999);
               //2 等待客户点链接
               socket = serverSocket.accept();
               //3. 读取客户端发送过来的IO流
               is = socket.getInputStream();
   
               //管道流， os 到 is 的一个中间媒介
               baos = new ByteArrayOutputStream();
               byte[] buffer = new byte[1024];
               int len;
               while((len=is.read(buffer)) != -1) {
                   baos.write(buffer, 0 , len);
               }
               System.out.println(baos.toString());
           } catch (IOException e) {
               e.printStackTrace();
           }finally {
               //关闭资源
               if (baos != null) {
                   try {
                       baos.close();
                   } catch (IOException e) {
                       e.printStackTrace();
                   }
               }
               if(is != null) {
                   try {
                       is.close();
                   } catch (IOException e) {
                       e.printStackTrace();
                   }
               }
               if(socket != null) {
                   try {
                       socket.close();
                   } catch (IOException e) {
                       e.printStackTrace();
                   }
               }
               if(serverSocket != null) {
                   try {
                       serverSocket.close();
                   } catch (IOException e) {
                       e.printStackTrace();
                   }
               }
           }
       }
   
   }
   
   ```

   

**SeverSocket:**

为了使客户能成功地连接到服务器，服务器必须建立一个ServerSocket 对象，该对象通过将客户端地套接字对象和服务器端地一个套接字对象连接起来，从而达到连接的目的。

客户端:(socket对象)socket(IP地址，端口)

服务器:(ServerSocket对象)serversocket(端口 )用ServerSocket.accept（）来建立一个和客户端的Socket对象相连接的Socket对象。

服务器端的输出流/输入流的目的地和客户端的输入流/输出流的源刚好相同。





















