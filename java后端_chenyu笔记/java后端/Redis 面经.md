### 1. Redis 为何这么快

#### 1.1 Redis的优点和缺点

优点：

1. 读写性能优异，Redis能读的速度是110000次/s，写的速度是81000次/s；
2. 支持数据持久化，支持AOF和RDB两种持久化方式；
3. 支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性操作；
4. 数据结构丰富，除了支持String类型的value外还支持hash,set,zset,list等数据结构；
5. 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。

缺点：

1. 数据库容量收到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上；
2. Redis不具备自动容错和恢复功能，主机从机宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复；
3. 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性；
4. Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。

#### 1.2 为什么要用Redis/为什么要用缓存

- 高性能：

假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变之后，同步改变缓存中响应的数据即可！

<img src="https://pic1.zhimg.com/v2-1edaa4ce51e0e839e5b2915beff38dac_r.jpg" alt="preview" style="zoom: 67%;" />

- 高并发：

直接操作缓存能够承受的请求是远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。

<img src="https://pic1.zhimg.com/v2-db3209720a621d3e1f08745859056a14_r.jpg" alt="preview" style="zoom: 67%;" />

#### 1.3 redis是单线程的，为什么还能这么快？

因此Redis完全基于内存操作，CPU不是redis的瓶颈，redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会称为瓶颈，那么就顺理成章地使用单线程地方案了：

1. Redis完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速，数据存在内存中，类似于HashMap, HashMap的优势就是查找和操作的时间复杂度是O(1)；
2. 数据结构简单，对数据的操作也简单；
3. 采用单线程，避免了不必要的上下文切换和竞争条件，不存在多线程导致的CPU切换，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗；
4. 使用多路复用IO模型，非阻塞IO；
5. 使用的底层模型不同，它们之间底层实现方法以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM机制，因为一般的系统调用系统函数的时候，会浪费一定的事件去移动和请求。

#### 1.4 多路复原IO模型原理

传统的并发模型：每个I/O流都有一个新的线程管理；

I/O多路复用：只有单个线程，通过追踪每个I/O流的状态，来管理多个I/O流。

<img src="https://pic4.zhimg.com/v2-8be3d5948f178144a83eec26e2fa2ab6_r.jpg" alt="preview" style="zoom:60%;" />

Redis-client在操作时，会产生不同事件类型的Socket。在服务端，有一段I/O多路复原程序，将其置于队列之中。然后，文件事件分配器依次去队列中取，转发到不同的事件处理器中。

### 2. 持久化

#### 2.1 Redis的持久化机制

Redis为了保证效率，数据存储在了内存中，但是会周期性地把更新的数据写入磁盘或者把修改操作写成追加的记录文件中，以保证数据的持久化。

Redis的持久化策略有两种：

- RDB(Redis database)：快照形式是直接把内存中的数据保存到一个dump的文件中，定时保存，保存策略；
- AOF(Append Only File)：把所有的对Redis的服务器进行修改的命令都存到一个文件里，命令的集合。

Redis默认是快照RDB的持久化方式。当Redis重启的时候，它会优先使用AOF文件来还原数据集，因为AOF文件保存的数据集通常比RDB文件所保存的数据集更完整。甚至可以关闭持久化功能，让数据只在服务器运行时保存。

RDB和AOF的区别

1. RDB是一次全量备份，AOF日志是连续的增量备份；
2. RDB是内存数据的二进制序列化形式，在存储上非常紧凑，而AOF日志记录的是内存数据修改的指令记录文本；

#### 2.2 RDB的工作流程

默认Redis是会以快照”RDB“的形式将数据持久化到磁盘的一个二进制文件dump.rdb。

工作原理：当Redis需要做持久化时，Redis会fork一个子进程，子进程将数据写到磁盘上一个临时RDB文件中。当子进程完成写临时文件后，将原来的RDB替换掉，这样的好处是可以copy-on-write。

优点：适用于备份。比如：你可以在最近的24小时内，每小时备份一次，并且在每个月的每一天也备份一个RDB文件。这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。RDB非常适合灾难恢复。

缺点：如果需要尽量避免在服务器故障时丢失数据，那么RDB不适合。

#### 2.3 AOF工作原理

使用AOF做持久化，每个写命令都通过write函数追加到appendonly.aof中，配置方式如下：

```bash
appendfsync yes
appendfsync always #每次有数据修改发生时都会写入AOF文件。
appendfsync everysec #每秒钟同步一次，该策略为AOF的缺省策略。
```

AOF可以做到全程持久化，只需要在配置中开启`appendonly yes`。这样redis每执行一个修改数据的命令，都会把它添加到AOF文件中，当redis重启时，将会读取AOF文件进行重放，恢复到redis关闭前的最后时刻。

优点：让redis变得非常耐久。可以设置不同的fsync策略，aof的默认策略时每秒钟fsync依次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据。

缺点：对于相同的数据集来说，AOF文件体积通常要大于RDB文件的体积。根据所使用的fsync策略，AOF的速度可能会慢于RDB。

###### ==fsync==

AOF日志是以文件的形式存在的，当程序对AOF日志进行写操作时，实际上是将内容写到了内核为文件描述符分配的一个内存缓存中，然后内核会异步将脏数据刷会到磁盘的。

这就意味着如果机器突然宕机，AOF日志内容可能还没有来得及完全刷到磁盘中，这个时间时候就会出现日志丢失。那该怎么办？

Linux的==glibc==提供了==fsync(int fd)==函数可以将指定文件的内容强制从内核缓存刷到磁盘。只要Redis进程实时调用fsync函数就可以保证aof日志不丢失。但是fsync是一个磁盘IO操作，它很慢！

#### 2.4 选择原则

如果你非常关心你的数据，但仍然可以承受数分钟内的数据丢失，那么可以只使用RDB持久。AOF将Redis执行的每条指令追加到磁盘中，处理巨大的写入会降低Redis的性能。

数据库的备份和灾难恢复：定时生成RDB快照非常便于进行数据库备份，并且RDB恢复数据集的数据也要比AOF恢复的速度快。

当然了，Redis支持同时开启RDB和AOF，系统重启后，Redis会有限使用AOF来恢复数据，这样丢失的数据最少。

### 3. 缓存问题

#### 3.1 缓存和数据库一致性问题

分布式环境下非常容易出现缓存和数据库间数据一致性问题，如果项目对缓存的要求是强一致性的，那么就不要用缓存。我们只能采用适当的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。合适的策略包括合适的缓存更新策略，更新数据库后及时更新缓存、缓存失败时增加重试机制。

#### 3.2 Redis雪崩

目前电商首页以及热点数据都会去做缓存，一般缓存都是定时任务去刷新，或者查不到之后更新缓存的，定时任务刷新就有一个问题。举个例子：

如果所有key的失效时间都是12小时，中午12点刷新的，零点有一个大促活动大量用户涌入，假设每秒6000个请求，本来缓存可以抗住每秒5000个请求，但是缓存中所有Key都失效了。此时6000个/秒的请求全部落在了数据库上，数据库必然扛不住，真实情况可能DBA都没反应过来就直接挂了，此时，如果没有什么特别的方案来处理，DBA很着急，重启数据库，但是数据库立马又被新流量给打死了。这就是缓存雪崩。

同一时间大面积失效，瞬间Redis跟没有一样，那这个数量级别的请求直接达到数据库上几乎是灾难性的，如果挂的是一个用户服务的库，那其他依赖他的所有接口几乎都会报错，如果没有做熔断等策略基本就是瞬间挂一片的节奏。

处理方法：

在批量往Redis存数据的时候，把每个Key的失效时间都加个随机值就好了，这样可以保证数据不会在同一时间大面积失效。

```java
setRedis（key, value, time+Math.random()*10000）;
```

如果Redis是集群部署，将热点数据均匀分布在不同的Redis库中也能避免全部失效。或者设置热点数据永不过期，有更新操作就更新缓存就好了（比如运维更新了首页商品，那就刷新缓存就好了，不用设置过期时间），电商首页的数据也可以用这个操作。

#### 3.3 缓存穿透和击穿

缓存穿透是指缓存和数据库都没有的数据，而用户（黑客）不断发起请求。举个例子：

我们数据库的id都是从1自增的，如果发起id=-1的数据或者id特别大不存在的数据，这样的不断攻击导致数据库压力很大，严重会击垮数据库；

缓存击穿跟是指某个Key非常热点，在不停地扛着大量请求，大并发集中地对这个点进行访问，当这个Key在失效地瞬间，持续地大并发直接落到了数据库上，就在这个Key的点上击穿了缓存。而缓存雪崩则是因为大面积地缓存失效。

解决方法

1. 缓存集权可以在接口层增加校验，比如用户鉴权、参数校验、不合法地校验直接return，比如id做基础校验，id<=0直接拦截；
2. “布隆过滤器(Bloom Filter)”能够很好地预防预防患侧穿透地发生，其利用高效地数据结构和算法快速判断处你这个Key是否在数据库中存在，不存在return就好了，存在就去查DB刷新KV再return；
3. 缓存击穿的话，设置热点数据永不过期，再加上互斥锁就搞定了。

```java
public static String getData(String key) throws InterruptedException {
        //从Redis查询数据
        String result = getDataByKV(key);
        //参数校验
        if (StringUtils.isBlank(result)) {
            try {
                //获得锁
                if (reenLock.tryLock()) {
                    //去数据库查询
                    result = getDataByDB(key);
                    //校验
                    if (StringUtils.isNotBlank(result)) {
                        //插进缓存
                        setDataToKV(key, result);
                    }
                } else {
                    //睡一会再拿
                    Thread.sleep(100L);
                    result = getData(key);
                }
            } finally {
                //释放锁
                reenLock.unlock();
            }
        }
        return result;
    }
}
```

#### 3.4 布隆过滤器的原理

每个布隆过滤器对应到Redis的数据结构里面就是一个大型的位数组和几个不一样的无偏hash函数。所谓的无偏就是能把元素的hash值算得比较均匀。

向布隆过滤器中添加key时，会使用多个hash函数对key进行hash算得一个证书索引值然后对位数组长度进行取模运算得到一个位置，每个hash函数都会算得一个不同的位置。再把数组的这几个位置都置为1就完成了add操作。

向布隆过滤器询问key是否存在时，跟add一样，也会把hash的几个位置都算出来，看看位数组中这几个位置是否都为1，只要有一个位为0，那么说明布隆过滤器中这个key不存在。如果都是1，这并不能说明这个key就一定存在，只是极有可能存在，因此这些位被置为1可能是因为其他的key存在所致。如果这个位数组比较稀疏，这个概率就会很大，如果这个位数组比较拥挤，这个概率就会降低。

使用时不要让实际元素远大于初始化大小，当实际元素开始超出初始化大小时，应该对布隆过滤器进行重建，重新分配一个size更大的过滤器，再将所有的历史元素批量add进去（这就要求我们在其他的存储器中记录所有的历史元素）。因为error_rate不会因为数量超出就急剧增加，这就给我们重建过滤器提供了较为宽松的时间。

### 4. Redis的淘汰策略

当Redis内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换（swap）。交换会让Redis的性能急剧下降，对于访问量比较频繁的Redis来说，这样龟速的提取效率基本上等于不可用。

在生产环境中我们不允许Redis出现交换行为的，为了限制最大使用内存，Redis提供了配置参数==maxmemory==来限制内存超出期望大小。

当实际内存超出==maxmemory==时，Redid提供了几种可选策略(maxmemory-policy)来让用户自己决定如何腾出新空间来继续读写服务。

- **noeviction**	不会继续服务写请求（DEL请求可以继续服务），读请求可以继续进行。这样可以保证不会丢失数据，但是会让线上的业务不能持续进行。这是默认的淘汰策略；
- **volatile-lru**    尝试淘汰设置了过期时间的key，最少使用的key优先被淘汰。没有设置过期时间的key不会被淘汰，这样可以保证需要持久化的数据不会突然丢失；
- **volatile-ttl**   跟上面一样，除了淘汰的策略不是LRU，而是key的剩余寿命ttl的值，ttl越小越优先被淘汰；
- **volatile-random**  跟上面一样，不过淘汰的key是过期key集合中随机的key；
- **allkeys-lru**  区别于volatile-lru，这个策略要淘汰的key对象是全体的key集合，而不只是过期的key集合。这意味着没有设置过期时间的key也会被淘汰；
- **allkeys-random**  跟上面一样，不过淘汰的策略是随机的key；

### 5. 主从复制

#### 5.1 连接过程

1. 主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始从服务器发送存储在缓存区中的写命令；
2. 从服务器丢失所有旧数据，载入主服务器发送的快照文件，之后从服务器开始接受主服务器发送的写命令；
3. 主服务器每执行一次写命令，就向从服务器发送相同的写命令。

#### 5.2 主从链

随着负载不断上升，逐服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。

<img src="https://pic4.zhimg.com/v2-81034e4168e0b70f60caac6619e48bfb_r.jpg" alt="preview" style="zoom:67%;" />

**Sentinel**（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器选举出新的主服务器。

#### 5.3 分片

分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线程级别的性能提升。

例如有4个Redis实例R0，R1，R2，R3，还有很多表示用户的键user:1，user:2，...，有不同的方式来选择一个指定的键存储在哪个实例中。

最简单的方式是范围分片，例如用户id从0-1000的存储到实例R0中，用户id从1001-2000的存储到实例R1中，等待。但是这样需要维护一张映射范围表，维护操作代价很高。

还有一种方式是哈希分片，使用CRC32哈希函数将键转换为一个数字，再对实例数量求模就能指定应该存储的实例。

根据执行分片的位置，可以分成三种分片方式：

1. 客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点；
2. 代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上；
3. 服务器分片：Redis Cluster

### 6. Redis基础数据结构

#### 6.1 字符串String

##### 6.1.1 基础

字符串String是Redis最简单的数据结构。Redis所有的数据结构都是以唯一的key字符串作为名称，然后通过这个唯一Key值来获取相应的value数据。不同类型的数据结构的差异在于value结构不一样。

String的一个常见用途是缓存用户信息。我们将用户信息结构体使用JSON序列化为字符串，然后将序列化后的字符串塞进Redis来缓存。同样，取用户信息会经过一次反序列化的过程。

Redis的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配，内部的当前字符串时间分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。

##### 6.1.2 探索「字符串」内部结构

#### 6.2 列表list

##### 6.2.1 基础

Redis的列表相当于Java语言里面的LinkedList，注意它是链表而不是数组。这意味着list的插入和删除操作非常快，时间复杂度为O(1)，但是索引定位很慢，时间复杂度为O(n)。

当列表弹出了最后一个元素之后，该数据结构自动被删除，内存被回收。

Redis的列表结构常用来保存异步队列使用。将需要延后处理的任务结构体序列化成字符串塞进Redis的列表，另一个线程从这个列表中轮询数据进行处理。

Redis底层存储的不是一个简单的==Linkedlist==，而是被称为快速链表==quicklist==的一个结构。

首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是==ziplist==，也即是压缩列表。它将所有的元素都紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改为==quicklist==。因为普通的链表需要的附加指针空间太大，会比较浪费空间，而且会加重内存的碎片化。比如这个列表里存的只是==int==类型的数据，结构上还需要两个额外的指针==prev==和==next==。所以Redis将链表和==ziplist==结合起来组成了==quicklist==。也就是多个==ziplist==使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。

##### 6.2.2 探索「快速列表」内部

#### 6.3 字典hash

##### 6.3.1 基础

Redis的字典相当于Java语言里面的HashMap，它是无序字典。内部实现结构上同Java的HashMap也是一致的，同样的数组+链表二维结构。第一维hash的数组位置碰撞时，就会将碰撞的元素使用链表串接起来。

<img src="C:\Users\cuimaolin\AppData\Roaming\Typora\typora-user-images\image-20210116121750440.png" alt="image-20210116121750440" style="zoom:50%;" />

不同的是，Redis的字典的值只能是字符串，另外它们rehash的方式也不一样，因为Java的HahMap在字典很大时，rehash是一个耗时的操作，需要一次性全部rehash。Redis为了高性能，不能堵塞服务，所以采用了渐进式rehash策略。

渐进式rehash会在rehash的同时，保留新旧两个hash结构，查询会同时查询两个hash结构，然后在后续的定时任务中以及hash的子指令中，循序渐进地将旧hash的内容一点点迁移到新的hash结构中。

当hash移除了最后一个元素时，该数据结构自动被删除，内存被回收。

hash结构也可以用来存储用户信息，不同于字符串需要全部序列化整个对象，hash可以对用户结构中的每个字段单独存储。这样当我们需要获取用户信息时可以进行部分获取。而以整个字符串的形式来保存用户信息的话就只能一次性全部读取，这样会比较浪费网络流量。

hash的缺点在于其结构的存储消耗要高于单个字符串。

##### 6.3.2 探索「字典」内部

#### 6.4 集合set

##### 6.4.1 基础

Redis的集合相当于Java语言里面的HashSet，它内部的键值对是无序且唯一的。它的内部实现相当于一个特殊的字典，字典所有的value都是一个值NULL。

当集合中的最后一个元素移除之后，数据结构自动删除，内存被回收。set结构可以用来存储活动中奖的用户ID，因为有去重功能，可以保证同一用户不会中将两次。

##### 6.4.2 探索「压缩列表」内部

#### 6.5 有序链表zset

##### 6.5.1 基础

zset类似于Java中的SortedSet和HashMap的结合体，一方面它是一个set，保证了内部value的唯一性，另一方面它可以给每个value赋予一个score，代表这个value的排序权重。它的内部实现用的是一种叫做[跳跃列表]的数据结构。

zset中最后一个value被移除后，数据结构自动删除，内存被回收。zset可以用来保存粉丝列表，value是粉丝的ID，score是关注时间。我们可以对粉丝列表按关注时间进行排序。

zset还刻意用来存储学生的成绩，value的值是学生的ID，score是他的考试成绩。我们可以对成绩按分数进行排序就可以得到他的名次。

==跳跃列表==

因为zset要支持随机的插入与删除，所以它不好使用数组来表示。我们需要这个链表按照score值进行排序。这意味着每当有新元素需要插入时，要定位到特定位置的插入点，这样才可以继续保证链表是有序的。通常我们会通过二分查找来找到插入点，但是二分查找的对象必须是数组，只有数组才可以支持快速位置定位。

跳跃列表类似于公司的层级制，最下面一层所有的元素都会串起来。然后每隔几个元素挑选出一个代表来，再将这几个代表使用另外一级指针串起来。然后在这些代表里再跳出二级代表，再串起来。最终就形成了金字塔结构。类似于世界地图的位置：亚洲-->中国->安徽省->安庆市->枞阳县->汤沟镇->田间村->xxxx号。

<img src="C:\Users\cuimaolin\AppData\Roaming\Typora\typora-user-images\image-20210116135617765.png" alt="image-20210116135617765"  />

[跳跃列表]之所以[跳跃]，是因为内部的元素可能[身兼数职]，比如上图中间的这个元素，同时处于L0、L1和L2层，可以快速在不同层次之间进行[跳跃]。

定位插入点时，现在顶层进行定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置，将新元素插入进去。

##### 6.5.2 探索「跳跃列表」内部结构